#№ Отчет по лабораторной работе №2
## по курсу "Логическое программирование"

## Решение логических задач

### студент: Морозов Артем Борисович М80-208Б-20

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|    18.12     |       5       |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Каждый из нас встречался с логическими задачами еще далеко-далеко в школе, однако далеко не каждый знает, что существует очень много специальных подходов к решению подобных задач.
Приведу самые базовые: 

`Метод рассуждений` - самый распространенный и одновременно примитивный метод решения логических задачек, заключающийся в последовательном итерировании по условию задания, предусматривающий учитывание всех фактов, предоставленных в задаче.

`Метод таблиц` - это тоже один из самых распространенных и простеньких методов, который идеально подходит для табличного представления данных задачи. Исходя из табличных данных уже конструируется подход к решению и, непосредственно, само решение.

`Метод кругов Эйлера` или же `графический` метод решения задач - метод, при котором возможные ветви решения представляются в виде неких абстрактных множеств, изображенных на листе бумаги. В качестве решения к задаче выступает пересечение всевозможных множеств.

Однако существуют так же и специальные методы решения логических задач именно на языке программирования, в том числе и на языке Prolog. Например: метод ветвей и границ, метод порождения и проверок.

```Метод ветвей и границ``` - метод, предполагающий "отбрасывание" заведомо неверных решений.

```Метод порождения и проверок``` - очень схожий по концепции с методом кругов Эйлера. Суть в том, что некий предикат является абстрактным множеством исходных данных, которые далее обрабатываются другими предикатами на предмет соответствия условию задачи.

В чем разница данных методов? Всё просто: количество переборов в первом методе намного меньше количества переборов во втором, так как в методе порождения и проверок предусмотрен возврат, предусматриваюший генерацию новых исходных данных с дальнейшей их проверкой. В остальных же аспектах приведенные выше методы полностью эквивалентны друг другу.

Но в чем же преимущество языка Prolog над остальными языками? Что ж, если мы говорим о возможности реализовывать решения логических задач, то очевидный ответ - бэктрекинг. Действительно, механизм бэктрекинга очень гибкий, ведь, по сути, при каждой неудаче совершается откат и продолжение решения в оставшемся дереве решений, что сильно экономит время и ресурсы. 

Еще один очевидный ответ - наличие возможности решать задачи, основываясь на одних только предикатах. Как известно, предикат может принимать только два значения: true (истина) или false (ложь). Это так же экономит время и ресурсы, ведь неподходящие по заданию ветви сразу отсекаются.

## Задание
15. Корнеев, Докшин, Мареев и Скобелев жители нашего города. Их профессии пекарь, врач, инженер и милиционер. Корнеев и Докшин соседи и всегда на работу ездят вместе. Докшин старше Мареева. Корнеев регулярно обыгрывает Скобелева в пинг-понг. Пекарь на работу всегда ходит пешком. Милиционер не живет рядом с врачом. Инженер и милиционер встречались один-единственный раз, когда милиционер оштрафовал инженера за нарушение правил уличного движения. Милиционер старше врача и инженера. Определите, кто чем занимается.

## Принцип решения

В школе во время прохождения той или иной темы по математике нам постоянно говорили: "Всё, что нужно сделать для решения задачи - грамотно перевести её на математический язык".
Забавно, но тут абсолютно такой же случай.

```Всё, что нужно сделать, чтобы решить данную логическую задачку - грамотно конвертировать данные задачи в предикаты на языке программирования Prolog!```

Несмотря на то, что я, как всегда, всё подробно описываю ещё в исходном прикрепленном коде, считаю нужным осветить реализацию и здесь. Итак, начнем!

Для начала внимательно прочитаем задачу и выделим "базисные" факты, которые нам пригодятся в процессе унификации в главном предикате программы. 
Лично я выделил 4 такие базовые вещи:

  1) Среди наших героев задачи есть игроки в пинг-понг (на данном этапе нам не важно, что это Корнеев и Скобелев, ведь самое главное это то, что таковые существуют).

В связи с этим имеет место предикат `pingpongplayers`, который определяет, что игроки на "условных" первых и вторых позициях играют в пинг-понг. Предикат выглядит следующим образом:

```prolog
pingpongplayers(Neighbor1, Neighbor2, List):-List = [Neighbor1,Neighbor2,_,_]; List = [Neighbor2,Neighbor1,_,_].
```

  2) Среди наших героев есть соседи.

Предикат `checkneighbors` ответственен за определение, являются ли соседями люди, стоящие на "условных" вторых и третьих местах:

```prolog
checkneighbors(Neighbor1, Neighbor2, List):-List = [_,Neighbor1,Neighbor2,_]; List = [_,Neighbor2,Neighbor1,_]. 
```

  3) Так как Корнеев и Докшин соседи и всегда ездят на работу вместе, то нам нужен специальный предикат `driveacar`, который истинен только в том случае, когда его аргументы являются соседями (опять же, на данном этапе нам нужно лишь объявление предиката - нас не интересует, кто там соседи, а кто нет, мы просто знаем о наличии таковых в нашей задаче).

```prolog
driveacar(Neighbor1,Neighbor2):-checkneighbors(Neighbor1,_,Neighbor2).
```

  4) Последний факт, нужный для написания основных предикатов задачи: некоторые из наших героев по условию задачи встречались между собой один-единственный раз. Реализуем его исходя из того, что эти люди точно не могут быть соседями и игроками в теннис.

```prolog
singlemeeting(Neighbor1,Neighbor2,List):-not(checkneighbors(Neighbor1,Neighbor2,List)), not(pingpongplayers(Neighbor1,Neighbor2,List)).
```

Замечательно! Всё, что нам осталось сделать для успешного решения задачи - реализовать главный предикат. Назовем его `mainpredicate`. Предикат будет принимать некий абстрактный список List. Вот как он выглядит:

```prolog
mainpredicate(List):-length(List, 4),                       
member((_,_,4), List), member((_,_,3), List), member((_,_,2), List), member((_,_,1), List),           
member((_,baker,_), List), member((_,doctor,_), List), member((_,policeman,_), List), member((_,engineer,_), List),          
checkneighbors((korneev,_,_), (dokshin,_,_), List), driveacar((korneev,_,_), List),driveacar((dokshin,_,_), List),
member((_,policeman, PolicemanYO), List), member((_,doctor,DoctorYO), List), PolicemanYO > DoctorYO,
member((dokshin,_, DokshinYO), List), member((mareev,_, MareevYO), List), DokshinYO > MareevYO,
member((_,engineer, EngineerYO), List), PolicemanYO > EngineerYO,
not(checkneighbors((_,policeman,_), (_,doctor,_), List)), singlemeeting((_,engineer,_), (_,policeman,_), List), 
not(driveacar((_,baker,_), List)), pingpongplayers((korneev,_,_),(skobelev,_,_), List).
```

Давайте пошагово разберем, для чего нужен каждый предикат в `mainpredicate`, какова его роль и суть относительно условия нашей задачи:

```prolog
length(List, 4)
``` 
- использование стандартного предиката `length`, нужное нам для того, чтобы обозначить, что в списке всего 4 человека. 

```prolog
member((_,_,X), List)
```
где X = {1,2,3,4} - использование стандартного предиката `member`, чтобы "условно" разграничить наших героев в следующей градации: 4 - самый возрастной, 1 - самый молодой.

```prolog
member((_,baker,_), List), member((_,doctor,_), List), member((_,policeman,_), List), member((_,engineer,_), List)
```
- использование стандартного предиката `member` для обозначения профессий наших героев.

```prolog
checkneighbors((korneev,_,_), (dokshin,_,_), List), driveacar((korneev,_,_), List), driveacar((dokshin,_,_), List)
``` 
- а вот и сопоставление с данными задачи! Нам важно знать, что Корнеев и Докшин - соседи и водят машину. Собственно говоря, я и говорил, что именно для этого нам нужны предикаты `checkneighbors` и `driveacar`.

```prolog
member((_,policeman, PolicemanYO), List), member((_,doctor,DoctorYO), List), PolicemanYO > DoctorYO,
member((dokshin,_, DokshinYO), List), member((mareev,_, MareevYO), List), DokshinYO > MareevYO,
member((_,engineer, EngineerYO), List), PolicemanYO > EngineerYO,
```
- очередное использование стандартного предиката `member`, в данном случае нужное для того, чтобы учесть неравенства возрастов наших героев, согласно условию задачи.

```prolog
not(checkneighbors((_,policeman,_), (_,doctor,_), List))
```
- обозначение того факта, что полицейский и доктор НЕ соседи.

```prolog
singlemeeting((_,engineer,_), (_,policeman,_), List)
```
- обозначение того факта, что инженер и полицейский виделись всего один раз, согласно условию задачи.

```prolog
not(driveacar((_,baker,_), List))
```
- обозначение того факта, что пекарь на работу всегда ходит пешком, согласно условию задачи.

```prolog
pingpongplayers((korneev,_,_),(skobelev,_,_), List)
```
- обозначение того факта, что Корнеев и Скоболев играют в пинг-понг.


Результат у программы следующий:

```prolog
?- mainpredicate(List).
List = [(skobelev, policeman, 4),  (korneev, doctor, 3),  (dokshin, engineer, 2),  (mareev, baker, 1)] ;
List = [(skobelev, policeman, 4),  (korneev, doctor, 2),  (dokshin, engineer, 3),  (mareev, baker, 1)] ;
List = [(skobelev, policeman, 4),  (korneev, doctor, 1),  (dokshin, engineer, 3),  (mareev, baker, 2)] ;
false.
```

Действительно: так как пекарь ходит на работу пешком, мы понимаем, что фамилия пекаря — не Корнеев и не Докшин (ведь они по условию задачи ездят на машине). 
Теперь учтем, что милиционер единственный раз встречался с инженером и не является соседом врача. Исходя из этих соображений можем сделать вывод, что пара соседей «Корнеев + Докшин» не может быть ни парой «милиционер + врач», ни парой «милиционер + инженер». Следовательно, `Корнеев и Докшин - врач и инженер, Скобелев - полицейский, а Мареев - пекарь`. Однако неизвестно, кто в паре «Корнеев - Докшин» есть кто. С учетом уже сделанных нами выводов, возрастных данных и последнего из условий задачи можно сказать, что милиционер старше Корнеева и Докшина.

Предикат нам так же вывел три возможных сценария для распределения возрастов героев:

  Скобелев, Докшин, Корнеев, Мореев

  Скобелев, Докшин, Мореев, Корнеев

  Скобелев, Корнеев, Докшин, Мореев

И это так же верно! Следовательно, противоречий нет, программа работает верно.

  ВАЖНОЕ ЗАМЕЧАНИЕ: асимптотика моего главного предиката `mainpredicate` равна `O(N)`, так как сложность всех предикатов, входящих в него, также равна `O(N)`.


## Выводы

Подводя итог данной лабораторной работы, хочется сказать, что логические задачи - это, наверное, один из самых интересных видов задач, которые только существуют. На мой взгляд, логические задачи играют очень важную роль в работе мозга человека. Именно они, как я убедился на своих жизненных примерах, заставляют работать максимальное количество мозговых извилин, именно базовые логические задачи служат отличным фундаментом для решения более сложных задач в дальнейшем. По моему мнению, умение быстро и эффективно решать логические задачи необходимо каждому человеку, так как это бесценный опыт и уникальная возможность прокачать себя в умственном плане.

Что же касается непосредственно лабораторной работы, то посредством нее возможности логических языков раскрылись для меня во всей красе. Данная задача была реализована мной с большим интересом и, как я считаю, очень эффективно, так как сложность работы программы - линейная, как было сказано выше. Если честно, то до этого момента для меня было невозможно представить, чтобы какой-либо из существующих языков программирования был бы способен на решение подобного типа логических задач.

Помимо этого, лабораторная работа еще сильнее сблизила меня с самим языком программирования Prolog, помогла мне намного глубже осознать парадигму логического программирования и окончательно отойти от прежнего консерватизма касательно императивных языков программирования: я окончательно понял, что мне, как программисту, обязательно нужно развиваться всесторонне, а не только в какой-то одной языковой концепции и в одном языке. Недаром Prolog занимает довольно высокое место в рейтинге популярности языков программирования, актуальном на 2021 год.
 
Благодаря данной лабораторной работе я в очередной раз закрепил навык работы со списками в языке и написанием предикатов, а также расширил свой функционал работы как программиста: я научился решать логические задачи на языке программирования! Решение логических задач посредством компьютера, как я считаю, такой же потрясающий и, безусловно, важный навык, как и решение логических задач устно или на бумаге, однако сначала очень важно научиться решать задачи при помощи только своей головы, а не посторонней программы.





