#№ Отчет по лабораторной работе №4
## по курсу "Логическое программирование"

## Обработка естественного языка

### студент: Морозов Артем Борисович М80-208Б-20

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|     18.12    |       5!      |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Вот мы с вами и подошли к четвертой, завершающей лабораторной работе по курсу логического программирования на языке Prolog! В данной лабораторной работе необходимо реализовать обработку естественных языков. 

Сразу же стоит сказать, что естественный язык - очень сложная система с неочевидной и непростой структурой. Любой анализ естественного языка сводиться к нескольким этапам: предварительный, морфологический, синтаксический анализ и, самое важное, семантический анализ. Не могу не отметить, что задачи подобного рода идеально подходят для концепции языков логического программирования. 

И вот почему: во-первых, безусловно, нельзя не упомянуть простоту перебора и простоту работы с символьной информацией. И ведь действительно, задумайтесь, насколько в этом плане Prolog наравне с другими логическими языками превосходит все остальные. Во-вторых: я на примере работы с языками C/C++ с уверенностью могу сказать, что работать с символами в Prolog намного веселее и, я бы даже сказал, приятнее. Дело в том, что С/C++ - это языки, которые используются немного более для других задач, нежели условный Prolog. Именно поэтому задачи наподобие заданий четвертой лабораторной идеально подходят именно к логическому языку программирования.

Помимо всего прочего, Prolog очень удобен для обработки текстов, трансляторов языков, перевода текста и многого другого. Все его достоинства вытекают из одного очень важного и базисного понятия данного языка - бэктрекинга. Ведь именно благодаря бэктрекингу мы можем из запроса делать некое "дерево общего вида" - каждый вопрос будет разбираться на подвопросы, подвопросы на еще одни подвопросы и так далее. 

Ну, думаю, пора нам убедиться в простоте и легкости языка Prolog на примере конкретного задания!



## Задание

3. Реализовать синтаксический анализатор арифметического выражения и вычислить его числовое значение. В выражении допустимы операции +,-,*,/,степень ^. Учитывать приоритеты операций.

## Принцип решения

Давайте подумаем, с чего же мы должны начать выполнять данное задание. Для начала нам нужно как-то дать нашей Prolog-программе понять, как отделять от наших арифметических знаков числа, нужные нам для получения результата. Оказывается, в данном языке программирования есть специальный предикат ```number```, который распознаёт рациональное число, либо же число с плавающей точкой. Отлично! Следовательно, первая строчка, являющаяся одновременно основой всего, будет выглядеть следующим образом:

```prolog
count([Head], Head):- number(Head).
```
Очень важным для выполнения лабораторной работы №4 во всех вариантах является идея, знакомая нам еще из далекой первой лабораторной работы - язык Prolog - это язык списков и рекурсии. То есть, наш список хранится в формате ```[Head|Tail]```, где ```Head``` - первый элемент списка, а ```Tail``` - все остальные элементы списка. И при рекурсивном обходе мы, на самом деле, делаем нашим ```Head-ом``` второй элемент списка, а всё остальное по-прежнему остается ```Tail-ом```.

Так вот, именно этот факт позволит нам грамотно обработать наш Prolog-запрос: 
```prolog
count(Value, Result) :- append(First, [-|Second], Value), count(First, Res1), count(Second, Res2), !, Result is Res1 - Res2.
```
Что же мы тут сделали? По определению списка мы можем сначала найти операцию с так называемым "минимальным приоритетом", а после вовсе разделить наш исходный список на два: по названию понятно, что новыми будут списки First и Second. И далее, как я уже оговорил, рекурсивно, мы обходим наш список в поиске самой глубокой по приоритету операции. Далее, по принципу Head-Tail, опять же, оговоренному выше, мы возвращаемся все выше и выше по рекурсии, пока не вернемся полностью назад. При возврате назад и будет подсчитан наш искомый результат. Таким образом, для сложения наш предикат ```count``` будет выглядеть следующим образом:

```prolog
count(Value, Result) :- append(First, [+|Second], Value), count(First, Res1), count(Second, Res2), !, Result is Res1 + Res2.
```
Для вычитания:

```prolog
count(Value, Result) :- append(First, [-|Second], Value), count(First, Res1), count(Second, Res2), !, Result is Res1 - Res2.
```
Для умножения:

```prolog
count(Value, Result) :- append(First, [*|Second], Value), count(First, Res1), count(Second, Res2), !, Result is Res1 * Res2.
```
Для деления:

```prolog
count(Value, Result) :- append(First, [/|Second], Value), count(First, Res1), count(Second, Res2), !, Result is Res1 / Res2.
```
А вот и нет! Понимаю, что обработки всех арифметических знаков очень похожи между собой, но в случае с делением будет не совсем так! А как же будет? По определению операции деления делить на ноль нельзя, следовательно, мы должны это обработать следующим образом: ```Res2 \= 0```, так как именно Res2 у нас стоит в знаменателе и нужна для рекурсивного подсчета в списке Second. Знак ```\=``` в прологе означает, что lvalue, выражаясь языком С++, не равно rvalue. Именно поэтому наш истинно правильный предикат для деления будет выглядеть так: 

```prolog
count(Value, Result) :- append(First, [/|Second], Value), count(First, Res1), count(Second, Res2), !, Res2 \= 0, Result is Res1 / Res2.
```
Ну и последнее - возведение в степень:

```prolog
count(Value, Result) :- append(First, [^|Second], Value), count(First, Res1), count(Second, Res2), !, Result is Res1 ** Res2.
```

Как мы видим, получилось очень необычно, интересно и совсем несложно! Давайте посмотрим результаты данных предикатов:


## Результаты

Давайте убедимся в правильности работы программы, для начала, на более простых примерах. Скажем ей, пожалуй, посчитать значение арифметического выражения "5+2". Для этого вызовем предикат count следующим образом:

```prolog
?- count([5, '+', 7], X).
```
Результат: ```X = 12.```

Супер! Давайте теперь что-нибудь посложнее:

```prolog
?- count([3, '+', 3, '*', 6, '/', 2], X).
```
Результат: ```X = 12.```

И ведь правда! Давайте посмотрим сами: выражение, записанное в аргументе предиката count, эквивалентно обычной, понятной всем записи - 3 + ((3*6) / 2).
Сначала считается 3+6 = 18, потом делится на 2 - получается 9. Ответом будет сумма тройки и девятки, то есть двенадцать.

Тааак, а давайте попробуем поделить на ноль, что же в таком случае нам выдаст Prolog?

```prolog
?- count([3, '+', 3, '*', 6, '/', 0], X).
```
Результат: ```false.```

Замечательно! Обработка опасного случая дала о себе знать - деления на ноль не произошло, Prolog выдал результат false. Давайте теперь последний, завершающий пример:

```prolog
?- count([3, '*', 3, '-', 6, '^', 0, '+', 4, '*', 2], X).
```
Результат: ```X = 0.```

Убедимся сами: (3*3) - (6^0 + 4*2) = 9 - (1+8) = 9-9 = 0. Программа работает исправно!

## Выводы

Что же можно сказать в конце? Я, наверное, уже порядком набил оскомину со своим сравнением абсолютно разных языков программирования из разных парадигм - Prolog и языки С-типа, но...

Я в очередной раз поражен тем, насколько все-таки Prolog может быть лаконичен и приятен в обращении с ним. Действительно, подобная программа на привычном нам языке заняла бы 100 строчек кода. Ведь из-за своей низкоуровневости в том же самом С++ мы должны были предусмотреть кучу всего сложного и затрудняющего жизнь: как нам хранить числа, как вычислять. Наверняка не обошлось бы без библиотеки STL, откуда бы мы взяли условный ```<stack>```. А если говорить про язык Си, то там и вовсе стек нужно было бы создавать самому. Более того, самая сложная лабораторная работа первого курса на Си, а именно "деревья выражений" - была именно на подсчет подобных вот арифметических операций с числами.

Это я к тому, что, опять же, нужно всегда помнить одну простую истину: язык программирования - это инструмент, никак не что-то большее. На примере данной лабораторной работы каждый из нас смог понять, что то, что на некоторых языках занимает довольно много времени, легко реализовать на условном Prolog. Экономия сил, нервов и ресурсов обеспечена!

Однако, в сторону защиты императивных языков, стоит сказать, что для программирования на логическом языке нужно сменить стиль мышления. Та же самая рекурсивная концепция и представление списков в Prolog - вещь довольно неоднозначная и понятная лишь интуитивно. Однако при должном подходе к делу любой уважающий себя программист привыкнет к подобным нюансам. 

Вот и подошел к концу курс логического программирования. Я бы искренне хотел поблагодарить всех причастных к данному курсу за то, что обучили принципиально иному стилю программирования, поменяли на многие вещи мое "программистское" мнение и обучили кардинально новому языку. Надеюсь, полученный опыт не пропадет даром, а, возможно, будет только расширяться. Спасибо Вам!
