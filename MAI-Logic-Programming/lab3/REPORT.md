#№ Отчет по лабораторной работе №3
## по курсу "Логическое программирование"

## Решение задач методом поиска в пространстве состояний

### студент: Морозов Артем Борисович М80-208Б-20

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|    18.12     |       5       |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Я уверен, что на примере предыдущих двух лабораторных работ практически каждый студент убедился, что пролог - очень необычный и удивительный язык, помогающий решать самого разного рода задачи. Мы убедились, что решать простые логические задачи на прологе - удовольствие. Но что же насчет сложных задач? Вот тут мы и подошли к такому понятию, как пространства состояний.

Дело в том, что пространство состояний представляет собой набор ситуаций. Из каждого состояния возможно перейти в другое состояние через определенное действие. Поэтому удобно использовать такой метод, когда у нас есть два заданных состояния - начальное и конечное, и число всевозможных состояний конечно. Если представить такое пространство как граф, где вершинами являются состояния, то путь от начальной вершины до конечной будет показывать набор состояний, являющийся решением задачи. В итоге, такие задачи сводятся к задаче поиска в графе.

Prolog имеет необходимый инструментарий для реализации подобных графов. Для перехода целесообразно будет использовать встроенный предикат ```move```, а любое состояние можно описать собственным предикатом. Путем перебора различных конфигураций данных будет осуществляться движение по графу. Кстати говоря, в этом плане Prolog значительно лучше, нежели привычные нам императивные языки, ведь в них мы бы хранили матрицу смежности, что намного затратнее и сложнее, чем использование предиката move.

Именно поэтому Prolog отлично подходит для решения не только простеньких задач, как было сказано в начале вступления, но и для решения подобных, далеко не самых простых задач!

## Задание

8. Вдоль доски расположены лунки, в каждой из которых лежит красный, белый или синий шар. Одним ходом можно менять местами два любых шара. Добиться того, чтобы сначала шли все красные шары, все синие - последними, а белые - посередине. Решить задачу за наименьшее число ход.

## Принцип решения

Думаю, уже по ходу прочтения условия задачи почти всем станет понятно, что нужно сделать. И действительно, алгоритм данной задачи довольно простой: мы просто должны итерироваться по списку из шаров, сравнивая 2 ближайших шара по принципу, оглашенному в условии задачи: меняем шары, если они не удовлетворяют нашему установленному порядку, и оставляем, если порядок правильный. Стоит отметить, что эта часть у меня отражена в предикате ```correct_order```. По условию наша последовательность такова "красные-синие-белые". Это эквивалентно тому, что после синих шаров не идут красные и белые, а после белых не идут красные:

```prolog
correct_order(X,Y,Z):- take_element(X,A,Y), take_element(X,B,Z),
((A == b, B == r); (A == b, B == w); (A == w, B == r)), !.
``` 

Работает он на основе вспомогательного предиката take_element, при помощи которого мы, собственно, и проходим по нашему списку, получая элемент:

```prolog
take_element([H|_],H, 0):-!.
take_element([_|T],A,C):- B is C-1, take_element(T,A,B).
```

Теперь переходим к, наверное, самой главной части моей лабораторной работы - описанию специального прологовского предиката ```move```:

```prolog
move([List|_],Result):- move(List,Result).
move(List,Result):- length(List,FirstLength), SecondLength is FirstLength - 1, 
between(0,SecondLength,X), between(0,SecondLength,Y), X @< Y, 
correct_order(List,X,Y), swap_element(List,X,Y,C), Result = C.
```
Этот предикат состоит из уже известного нам предиката ```correct_order```, а также из предиката ```swap_element``` и из стандартных предикатов ```between``` и ```length```, который нам также известен по первой лабораторной. 

В чём же суть данного предиката? Суть в том, что мы представляем наш обход листа как некий набор состояний. Иными словами, роль предиката ```move``` - выполнять переходы между нашими состояниями (изменениями в последовательности шаров). При помощи встроенного предиката ```between```, генерирующего целые числа от 0 до какой-то длины L, мы проверяем правильность расположения элементов с меньшим порядковым индексом относительно элементов с большим порядковым индексом при помощи поиндексного сравнения: ```i @< j```. 

Реализация же каждого из моих предикатов поиска довольно простая и похожая друг на друга: на вход дается исходный список с рандомным расположением цветов, и список, где все упорядочено, которое программа в конце своей работы и обязана получить. Программа при помощи своих перестановок и работы предиката ```move``` на каждом шаге печатает нам результаты. При этом время тоже засекается, поэтому на выходе получим и его тоже.

Реализация поиска в ширину:
```prolog
breadth_searching_predicate(X,Y):-get_time(CurTime),
breadth_search([[X]],Y,List), inv_print(List), get_time(EndTime),
TimeDifference is EndTime - CurTime, write('Time passed: '), write(TimeDifference), nl.
```

В глубину:
```prolog
depth_searching_predicate(A,B):-get_time(CurTime), depth_search([A],B,Head),
inv_print(Head), get_time(EndTime), TimeDifference is EndTime - CurTime,
write('Time passed: '), write(TimeDifference), nl.
```

С итерационным заглублением:
```prolog
iterative_searching_predicate(H,T):-get_time(CurTime),
int(List), depth_check([H],T,Result,List), inv_print(Result),
get_time(EndTime), TimeDifference is EndTime - CurTime,
write('Time passed: '), write(TimeDifference), nl.
```

## Результаты

Что же, давайте посмотрим результаты работы наших предикатов на практике. Первым пусть будет предикат поиска в ширину:
```prolog
?- breadth_searching_predicate([b,r,w,r,r,b,w,r,b],[r,r,r,r,w,w,b,b,b]).
([b,r,w,r,r,b,w,r,b])
([r,r,w,r,r,b,w,b,b])
([r,r,r,r,w,b,w,b,b])
([r,r,r,r,w,w,b,b,b])
Time passed: 0.2069122791290283
```

Так, давайте запомним наше время: 0.2069122791290283. Выглядит довольно быстро. Теперь очередь поиска в глубину:
```prolog
?- depth_searching_predicate(([b,r,w,r,r,b,w,r,b]),([r,r,r,r,w,w,b,b,b])).
([b,r,w,r,r,b,w,r,b])
([r,b,w,r,r,b,w,r,b])
([r,w,b,r,r,b,w,r,b])
([r,r,b,w,r,b,w,r,b])
([r,r,w,b,r,b,w,r,b])
([r,r,r,b,w,b,w,r,b])
([r,r,r,w,b,b,w,r,b])
([r,r,r,r,b,b,w,w,b])
([r,r,r,r,w,b,b,w,b])
([r,r,r,r,w,w,b,b,b])
Time passed: 0.02994394302368164
```

Пройденное время - 0.02994394302368164. И это при том условии, что 10 - действительно минимальное число перестановок в данном случае! Весьма неплохо. Однако давайте для чистоты эксперимента проверим еще и итерационное заглубление:
```prolog
?- iterative_searching_predicate(([b,r,w,r,r,b,w,r,b),([r,r,r,r,w,w,b,b,b])).
([b,r,w,r,r,b,w,r,b])
([r,r,w,r,r,b,w,b,b])
([r,r,r,r,w,b,w,b,b])
([r,r,r,r,w,w,b,b,b])
Time passed: 0.0008881092071533203
```

Кажется, у нас есть победитель! Давайте на основе полученных результатов построим следующую таблицу:

```
! Алгоритм поиска | Время работы                      |
|---------------------------------------------------- |
| В глубину       | 0.02994394302368164               |
| В ширину        | 0.2069122791290283                |
| ID              | 0.0008881092071533203 (!!!)       |
```

## Выводы

В конце данной лабораторной работы хочется сказать, что я получил отличный навык работы с графами и переходами между состояниями на языке программирования Prolog. 
Что же хочется обсудить по этому поводу? А хочется обсудить следующее: неожиданно для меня я осознал, что работа с графами тут обстоит немного по-другому, нежели в императивных языках. И "по-другому" - в лучшую сторону! Так как Prolog - это лаконичный язык программирования, то алгоритмы поиска на нем реализуются гораздо проще и, возможно, даже приятнее, нежели в моём любимом С++. Все-таки далеко не последнюю роль играет синтаксис языка.

Касаемо своего задания хотелось бы сказать, что я в очередной раз потренировал навык работы с подобными алгоритмами. В очередной раз я убедился, что поиск в ширину хорош для поиска кратчайшего пути (тут же, кстати говоря, вспоминаются олимпиадные задачи по С++ с 1 курса, где очень многое решалось при помощи этого алгоритма). Поиск в глубину дает нам огромный запас по памяти, но по времени, например, на тех же олимпиадных задачах 1 курса, он не всегда проходил. А вот поиск с итерационным заглублением - это, наверное, некая квинтэссенция всего хорошего, что есть в поиске в глубину и в ширину.

Судите сами: он работает быстрее каждого, но при этом пользуется их же плюсами: экономией по памяти и поиском кратчайшего пути. Но беда в том, что такой поиск вряд ли применим на очень сложных задачах. Однако в простых задачах итеративное заглубление - самый лучший вариант.

В конце хотелось бы сказать, что несмотря на то, что курс по программированию на языке Prolog подходит к концу, я могу с уверенностью сказать, что этот курс меня многому научил и помог по-другому посмотреть на сферу программирования в целом. Радует, что впереди меня ждет еще одна, заключительная лабораторная №4.

