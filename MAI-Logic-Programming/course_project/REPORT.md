# Отчет по курсовому проекту
## по курсу "Логическое программирование"

### студент: Морозов Артем Борисович М80-208Б-20

## Результат проверки

Вариант задания:

 - [ ] стандартный, без NLP (на 3)
 - [x] стандартный, с NLP (на 3-4)
 - [ ] продвинутый (на 3-5)
 
| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |     3          |
| Левинская М.А.|              |               |

> *Понравился парсер на Прологе. 3 балла по рез-татам собеседования*

## Введение

В процессе выполнения курсового проекта по предмету "Логическое программирование" я преследую несколько целей:
1) Ознакомиться с языком Prolog ещё ближе. Реализовать все предикаты, требуемые по заданию курсового проекта. Изучить все тонкости, освоить на достойном уровне парадигму логического программирования, так сказать, "перестроить" мозг - осознать, что помимо привичных мне и, уверен, каждому на нашем курсе, императивных языков программирования, существуют не менее интересные и, что самое главное, полезные и развивающие логические языки.
2) Вспомнить историю своей семьи, сделать родословное дерево в формате GEDCOM.
3) Научиться парсить GEDCOM файлы. К слову говоря, писал парсер я на Prolog, а выбрал его как раз таки исходя из рассуждений, озвученных мною в пункте 1).
4) Реализовать работающий и качественный интерфейс, как требуется в задании №5.

## Задание

Вариант 15 по списку группы. 
Задания:
1) Создать родословное дерево своего рода на несколько поколений (3-4) назад в стандартном формате GEDCOM.
2) Преобразовать файл в формате GEDCOM в набор утверждений на языке Prolog, используя представление II: `parent(родитель, ребенок)`, `sex(человек, m/f)`.
3) Реализовать предикат поиска шурина на языке Prolog.
4) Реализовать программу на языке Prolog, которая позволит определять степень родства двух произвольных индивидуумов в дереве.
5) Реализовать естественно-языковый интерфейс к системе, позволяющий задавать вопросы относительно степеней родства, и получать осмысленные ответы.

## Получение родословного дерева

Родословное дерево я получил благодаря сайту MyHeritage.com, как и было рекомендовано в описании стандартного задания. Моё родословное дерево насчитывает 33 человека, а если говорить о поколениях, то в моем дереве присутствуют 5 поколений. Этого более чем достаточно для вариативного и правильного результата работы тех предикатов, которые требовались в заданиях 3-5.

## Конвертация родословного дерева

Как я уже писал выше, парсер для GEDCOM файла я писал на языке Prolog, так как задался целью узнать этот язык еще лучше. Все подробные описания есть в файле gedparser.pl, но я все равно считаю нужным осветить реализацию парсера в своем отчете. 
```prolog
nameline(A, [X, Y, Z|SOMETHING], B, C):-X = "0", Y = B, Z = "INDI", read_string(A, "\n", "\r",_,_), 
read_string(A, "\n", "\r", _, _), read_string(A, "\n", "\r",_, N), split_string(N, " ", "", NL), 
linetreatment(NL, CN_), read_string(A, "\n", "\r",_, S), split_string(S, " ", "", SL), linetreatment(SL, CS), 
string_concat("'", CN_, CN), string_concat(CN, " ", R), string_concat(R, CS, R_), string_concat(R_, "'", C).

nameline(A, B, C, D).
namefile(A, B, C):-at_end_of_stream(A), !.
namefile(A, B, C):-read_string(A, "\n", "\r", EOF, S), split_string(S, " ", "", SS), nameline(A, SS, B, C), namefile(A, B, C).
getperson(A, B):-open("familytree.ged", read, C), namefile(C, A, B).
childchecker([A, "CHIL", B]).
linetreatment([A, B, C], C).
childtreatment(A, RESULT):-read_string(A, "\n", "\r",_, B), split_string(B, " ", "", C), childchecker(C), 
linetreatment(C, CUR), childtreatment(A, P), RESULT = [CUR|P].

childtreatment(A, []).
printpredicate(HID, WID, [], FD1).
printpredicate(HID, WID, [CURID|TID], FD1):-getperson(CURID, CURRENT), getperson(HID, HUSBAND), 
getperson(WID, WIFE), write(FD1, "parent("), write(FD1, HUSBAND), write(FD1, ", "), write(FD1, CURRENT), 
write(FD1, ").\n"), write(FD1, "parent("), write(FD1, WIFE), write(FD1, ", "), 
write(FD1, CURRENT), write(FD1, ").\n"), printpredicate(HID, WID, TID, FD1).

parentline(A, B, [X, Y, Z|SOMETHING]):-X = "0", Y = FID, Z = "FAM", read_string(A, "\n", "\r",_,_), 
read_string(A, "\n", "\r", SS, HS), split_string(HS, " ", "", HSL), linetreatment(HSL, CH), 
read_string(A, "\n", "\r",_, WF), split_string(WF, " ", "", WL), linetreatment(WL, CW), 
childtreatment(A, CC), printpredicate(CH, CW, CC, B), !.

parentline(A, B, C).
sexfile(A, B):-at_end_of_stream(A), !.
sexfile(A, B):-read_string(A, "\n", "\r", EOF, S), split_string(S, " ", "", SS), sexline(A, B, SS), sexfile(A, B).
parentfile(A, B):-at_end_of_stream(A), !.
parentfile(A, B):-read_string(A, "\n", "\r", EOF, S), split_string(S, " ", "", SS), parentline(A, B, SS), parentfile(A, B).
fillfile("M", N, S, FD1):-string_concat("'", N, N_), string_concat(N_, " ", RT), 
string_concat(RT, S, R_), string_concat(R_, "'", R), write(FD1, "sex("), write(FD1, R), write(FD1, ", 'm').\n").

fillfile("F", N, S, FD1):-string_concat("'", N, N_), string_concat(N_, " ", RT), string_concat(RT, S, R_), 
string_concat(R_, "'", R), write(FD1, "sex("), write(FD1, R), write(FD1, ", 'f').\n").

sexline(FD0, FD1, [X, Y, W|SOMETHING]):-X = "0", Y = FID, W = "INDI", read_string(FD0, "\n", "\r",_,_), 
read_string(FD0, "\n", "\r",SS,ST), read_string(FD0, "\n", "\r",_, NS), split_string(NS, " ", "", NL), 
linetreatment(NL, N), read_string(FD0, "\n", "\r", _, SN), split_string(SN, " ", "", SNL), linetreatment(SNL, SN1), 
read_string(FD0, "\n", "\r",_, S_), split_string(S_, " ", "", SL), linetreatment(SL, S), fillfile(S, N, SN1, FD1). 
sexline(S1, S2, S3).

gedparser:-open("familytree.ged", read, FD0), open("familytree.pl", write, FD2), parentfile(FD0, FD2), close(FD0), 
open("familytree.ged", read, FD1), sexfile(FD1, FD2), close(FD2), close(FD1). 
```
На первый взгляд может показаться, что этот код какой-то очень страшный и непонятный, но уверяю вас: если понять суть того, что делает данный парсер, то тут все очень легко и вполне очевидно. Единственное, что может смущать - это синтаксис языка Prolog. Но и тут, опять же, все довольно несложно: лично я привык к его синтаксису буквально за месяц и нахожу его очень интересным, своеобразным и даже уникальным!

Итак, что делают предикаты в моей реализации парсера? Давайте обо всём по порядку:

Предикат ```nameline``` вызывается предикатом ```namefile```, который занимается считыванием строки. Сам предикат ```nameline``` проверяет текущую строку на соответствие нужному нам паттерну(0 @I***@ INDI) и в случае успеха конвертирует и записывает информацию о человеке в переменную.

Предикат ```getperson``` распознает человека по его ID. Предикат ```childchecker``` принимает ключевое слово CHIL, без которого не обходится ни одна строка с ребенком в нашем файле GEDCOM. Этот предикат просто сопоставляет строке со словом CHIL ребенка и конвертирует его информацию в переменную. Предикат ```linetreatment``` помогает нам точно распарсить файл, обрабатывая полностью всю строку.

Предикат ```childtreatment``` обрабатывает всех детей в семье. Предикат ```printpredicate``` заносит в нашу базу данных информацию о конкретной семье (родители и их дети). Предикат ```parentline``` служит вспомогательным предикатом, который помогает нам удостовериться, начинается ли строка с семейного блока. 

Группа предикатов ```sexfile``` и ```parentfile``` помогают нам непосредственно по заданию II: они конвертируют строки последовательно в набор утверждений с помощью нужных нам предикатов parent-sex. Предикат ```fillfile``` при конвертации GEDCOM файла в нужный нам набор утверждений сопоставляет каждому человеку его пол: male или female (f или m). При помощи них и осуществляется работа предиката ```sexline```, который парсит строки с полом человека. 

Ну и, наконец, предикат ```gedparser``` открывает наш файл familytree.ged, при помощи предикатов ```sexfile``` и ```parentfile``` ищет информацию о том, какого каждый человек пола, и о его родственных связях, парсит GEDCOM файл и выводит нужный нам результат в формате предикатов parent-sex в файл familytree.pl. На этом работа программы считается завершенной.

## Предикат поиска родственника

Реализация предиката i: Шурин.
```prolog
brother_in_law(A, B):-sex(A, 'm'), parent(A, C), parent(D, C), D \= A, parent(E, D), sex(E, 'f'), parent(E, B), sex(B, 'm'). 
```
`brother_in_law(A, B)` - предикат, который определяет, является ли А шурином для B, и наоборот.

Реализация данного предиката очень простая: для начала нам нужно определить, кого мы будем называть шурином: шурин - это брат жены. Это значит, что мы в реализации нашего предиката сразу можем написать, что переменные A и B в результате унификации не будут затрагивать представителей женского пола.

Достигается это путем объявления двух следующих предикатов: `sex(A, 'm')`, `sex(B, 'm')`. Отлично!

Следующий шаг заключается в том, что нам необходимо найти жену для А. Как это можно сделать при помощи предикатов `parent(родитель, ребенок)` и `sex(человек, m/f)`? 

На мой взгляд, самый простой и эффективный способ - связать наших супругов общим ребенком.

*ВАЖНОЕ ЗАМЕЧАНИЕ: в моем родословном дереве в каждой семье есть хотя бы один ребенок, поэтому эта логика верна.*

Связываем мы их следующим образом: `parent(A, C)`, `parent(D, C)`. При этом очень важно дать программе понять, что под А и D мы имеем в виду не одного и того же человека: `D \= A`. Без этого предикат правильно работать не будет.

Далее нам нужно уйти вглубь родословного дерева, а именно - найти маму для жены А. Делается это следующим образом: `parent(E, D)`, `sex(E, 'f')`. 

После этого нам остаётся просто найти сына мамы жены А, если он есть: `parent(E, B)`, `sex(B, 'm')`. Вот и всё! B - шурин для А! 

По моему мнению, предикат получился очень лаконичным и, самое главное, идеально работающим! Давайте с вами в этом убедимся на нескольких разных примерах:
```prolog
?-brother_in_law('Борис Морозов', Y), write(Y).
Y = 'Александр Тараканов' .
```
```prolog
?-brother_in_law('Борис Морозов','Александр Тараканов').
true.
```
```prolog
?- brother_in_law('Алексей Горшелев', Y), write(Y).
Y = 'Борис Морозов' .
Y = 'Анатолий Горшелев' .
```
```prolog
?- brother_in_law('Алексей Горшелев', 'Александр Тараканов').
false.
```
```prolog
?- brother_in_law('Алексей Горшелев', 'Анатолий Горшелев').
true.
```
```prolog
?- brother_in_law('Сергей Кинжалов', Y).
Y = 'Максим Горшелев' .
```
```prolog
?- brother_in_law('Сергей Кинжалов', 'Максим Горшелев').
true.
```


## Определение степени родства

Итак, переходим к четвертому заданию курсового проекта. Для выполнения этого курсового проекта я воспользуюсь знаниями, полученными в третьей лабораторной работе - а именно, я реализую поиск с итерационным заглублением для своего родословного дерева, чтобы найти все родственные связи. 
Почему именно такой вид поиска я выбрал для курсового проекта? Потому что 3 лабораторная явно не прошла мимо меня - а именно, я окончательно убедился в том, что поиск с итерационным заглублением действительно включает в себя лучшие качества поисков в глубину и в ширину.

Что же для начала нужно сделать? Самый первый шаг - написать нужные нам предикаты для определения, так называемой, ближайшей степени родства. Давайте рассмотрим полученные предикаты!

Для определения связи отец-мать:
```prolog
relation(Father, Person, father):- parent(Father, Person), sex(Father, 'm').
relation(Mother, Person, mother):- parent(Mother, Person), sex(Mother, 'f').
```

Для определения связи сын-дочь:
```prolog
relation(Person, Parent, son):- parent(Parent, Person), sex(Person, 'm').
relation(Person, Parent, daughter):- parent(Parent, Person), sex(Person, 'f').
```

Для определения связи брат-сестра:
```prolog
relation(Person, HelpPerson, brother) :- parent(Parent, Person), parent(Parent, HelpPerson), Person \= HelpPerson, sex(Person, 'm').
relation(Person, HelpPerson, sister) :- parent(Parent, Person), parent(Parent, HelpPerson), Person \= HelpPerson, sex(Person, 'f').
```

Для определения связи муж-жена:
```prolog
relation(Husband, Wife, husband):- parent(Wife, Person), parent(Husband, Person), Husband \= Wife, sex(Husband, 'm').
relation(Wife, Husband, wife):- parent(Wife, Person), parent(Husband, Person), Husband \= Wife, sex(Wife, 'f').
```

Для определения связи бабушка-дедушка:
```prolog
relation(Person, GrandFather, grand_father):- parent(HelpPerson, Person), parent(GrandFather, HelpPerson), sex(GrandFather, 'm').
relation(Person, GrandMother, grand_mother):- parent(HelpPerson, Person), parent(GrandMother, HelpPerson), sex(GrandMother, 'f').
```
Супер! Мы реализовали все наши столь необходимые предикаты. Осталось только при помощи поиска с итерационным заглублением найти всевозможные родственные связи для двух людей:
```prolog
relative(X, Y, Res):- iterative_searching_predicate(X, Y, Res), !.
```

Давайте посмотрим на итог нашей работы:

```prolog
?- relative('Александр Тараканов', 'Ирина Тараканова', Result).
Result = [brother].
```
И действительно, Александр Тараканов - мой дядя, а Ирина Тараканова - моя мама. Значит, Александр Тараканов - брат моей мамы. В этом можно убедиться, посмотрев мое родословное дерево. Следовательно, предикат работает верно.

```prolog
?- relative('Борис Морозов', 'Ирина Тараканова', Result).
Result = [husband].
```
То же самое: Ирина Тараканова моя мама, Борис Морозов мой папа. Все сходится. Однако давайте проверим наоборот:

```prolog
?- relative('Ирина Тараканова', 'Борис Морозов', Result).
Result = [wife].
```
Отлично! Наоборот тоже все верно работает: Ирина Тараканова - жена Бориса Морозова.

```prolog
?- relative('Александр Тараканов', 'Артем Морозов', Result).
Result = [brother, mother].
```
Абсолютно правильно! Так как Александр Тараканов - мой дядя, то он является братом моей мамы, что нам и выдала программа. Давайте напоследок рассмотрим более сложный случай:
```prolog
?- relative('Александр Тараканов', 'Елена Горшелева', Result).
Result = [brother, wife, brother, mother].
```
Великолепно! Так как Елена Горшелева - дочь Татьяны Горшелевой, Татьяна Горшелева - сестра Бориса Морозова (следовательно, Борис Морозов - ее брат), а wife для Бориса Морозова - Ирина Тараканова, то мы получаем, что Александр Тараканов брат Ирины Таракановой, а в достоверности этого факта мы уже убедились на самом первом примере.

## Естественно-языковый интерфейс

Ну что же, вот мы и подошли к финальному заданию курсового проекта - реализации естественно-языкового интерфейса. Скажу честно, сделать это было довольно непросто, но, кажется, я справился. Благодаря четвертой лабораторной работе у меня появился навык работы с обработкой естественных языков, и именно его я и применил для выполнения данного задания курсового проекта. 

В чем идея создания языкового интерфейса? Идея состоит в реализации кучи соответствий и сопоставлений, на которые мы и будем опираться. То есть, сначала, мы создали всевозможные соответствия для степени родства в семье, сделали соответствие между единственным и множественным числом для определения количества родственников во избежание недоразумений в работе программы, а после сделали соответствия и для местоимений, вопросительных знаков, слов "how", "who" из начала вопроса, апострофов и так далее...

```prolog
check_relation(X):- member(X, [father, mother, sister, brother, daughter, son, wife, husband, grand_mother, grand_father]).
check_relative(A, B, C):- check_relation(C), !, relation(A, B, C).

beginning_of_question(Val) :- member(Val, [how, who, "How", "Who"]).
indefinite_prns(Val) :- member(Val,[much, many]).
relatives(Val) :- member(Val, [sisters, brothers, sons, daughters, grand_mothers, grand_fathers]).
family_accordance(sister, sisters).
family_accordance(brother, brothers).
family_accordance(grand_mother, grand_mothers).
family_accordance(grand_father, grand_fathers).
family_accordance(son, sons).
family_accordance(daughter, daughters).
auxiliary_do(Val) :- member(Val, [do, does]).
pronouns_list(Val) :- member(Val, [his, her, he, she]).
auxiliary_have(Val) :- member(Val, [have, has]).
is(Val) :- member(Val, [is]).
engl_ap(Val) :- member(Val, [" s"]).
interrogate(Val) :- member(Val, ['?']).
```

Вот. Это наша база, отвечающая и за корректность введения вопроса, и за корректность введеных данных. После этого мы обрабатываем все типы вопросов, парсим их на части и проводим сопоставление между этими частями вопроса и вышеупомянутыми предикатами. 

Стоит отметить, что эта логика работает даже для блока с анализом текста. Там мы тоже дробим вопрос на части и при помощи сопоставлений обрабатываем вопрос. 
Что же касается запоминания программой текущих имен, для которых можно задать вопрос наподобие ```how many daughters does he have?```, то для этого, оказывается, существуют встроенные предикаты! Это предикаты ```nb_setval``` и ```nb_getval```. Первый предикат запоминает имя прошлого вопроса, второй предикат проверяет корректность данного запроса исходя из родственных связей в семье. 

Также при анализе текста создается куча мини-предикатов, которые определяют конкретный тип: например, предикат ```have_or_has``` при анализе выдает либо have, либо has. Предикат ```do_or_does``` работает аналогично. ```question_beginning``` выдает либо слово who, либо how. ```relation_type``` в зависимости от родства принимает значение son, daughter, brother и так далее. Ну и куда же без обработки вопросительного знака и начального времени глагола to be (чтобы обработать запрос а-ля ```who is Борис Морозов s son?```: за это отвечают предикаты ```helpverb``` и ```special_symbol```. 

Какой толк говорить? Давайте увидим работу данного интерфейса:
```prolog
?- question([who, is, 'Артем Морозов', " s", mother, ?]).
Ирина Тараканова is Артем Морозов s mother
```

```prolog
?- question([how, many, brothers, does, he, have, ?]). %результат работы предиката nb_setval (имя запомнилось)
Артем Морозов have 1 brother
```

```prolog
?- sentence_parser([who, is, 'Борис Морозов', " s", son, ?], X).
X = sentence(sentence_parse_is:(question_beginning(who), helpverb(is)), names_list(cur_person:('Борис Морозов', " s")), relation_type(son), special_symbol(?))
```
Как мы видим, все предикаты работают слаженно, а что самое главное, верно!

## Выводы

Вот она, та самая минута, когда я пишу вывод по курсовому проекту по курсу "Логическое программирование". А раз я так делаю, значит, курсовой проект полностью мною доделан, лабораторные сданы, следовательно, курс подходит к, извиняюсь за тавтологию, логическому завершению. В самом начале отчета я писал, что преследую по мере выполнения работы сразу несколько целей. Так вот, с уверенностью могу сказать, что эти цели были достигнуты!

На мой взгляд, реализовать курсовой проект полностью было очень непростой задачей, учитывая большую нагрузку по другим предметам и новизну темы в целом. Однако несмотря на это, я считаю его безумно ценным опытом, и на это есть несколько причин:
1) Курсовой проект - это, независимо от курса, повторение и отработка пройденного материала, накопление уже полученных знаний и получение новых.
2) Как я писал в отчетах к своим лабораторным, парадигма логического программирования для меня, как и, наверное, для всех студентов - это абсолютно новый, неизведанный и ранее невиданный мир. На протяжении этих 3,5 месяцев было очень приятно осознавать, что, несмотря на трудности, ты изучаешь что-то кардинально новое, ты не придерживаешься старых взглядов и не остаешься приверженцем одних лишь привычных императивных языков по типу С++, Python и так далее. Ты понимаешь, что каждый язык хорош по-своему, особенно язык с неизвестными для тебя ранее концепциями - такой, как Prolog.
3) Курсовой проект - это еще одна возможность прокачать свой скилл самообразования, ведь, чтобы выполнить его достойно, необходимо обращаться к дополнительным источникам и придумывать оригинальный выход даже из самых непростых и заковыренных задач.

Подводя итог, хочется сказать одно: было интересно, но и трудно. Prolog - удивительный, необычный и легкочитаемый язык, сочетающий в себе многие положительные качества. На мой взгляд, главным достоинством данного языка служит принципиально отличный от привычных языков программирования подход к описанию способа решения какой-либо задачи, так как программа описывает не процедуру решения задачи, а именно логическую модель предметной области. Иными словами, Prolog оперирует одними лишь фактами, свойствами и отношениями между ними. Именно поэтому он, кстати говоря, и называется описательным.

Курсовой же проект еще раз научил меня руководствоваться логикой "фактов и правил", писать обработку естесственных языков и прокачал мое логическое мышление. Уверен, что опыт, полученный мной при работе на данном языке, обязательно даст о себе знать в будущем.
