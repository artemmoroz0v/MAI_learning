# Реферат
## по курсу "Логическое программирование"

### студент: Морозов Артем Борисович М80-208Б-20

## ТЕМА

iii. Как научить вашу бабушку/дедушку логическому программированию.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

## 1. Введение

Что ж, стоит признать, что мне попалась очень интересная и довольно необычная тема для написания эссе. 
Ни для кого ни секрет, что чем старше человек, тем труднее ему учиться. Это всемирно известный факт, доказанный наукой. Например, моим бабушке и дедушке обоим семьдесят лет, и научить их чему-либо будет, вероятно, весьма непросто. Однако давайте попробуем-таки закрыть на это глаза и во что бы то ни стало попытаемся обучить наших родственников нелегкому делу, но перед этим поймем следующее: прежде чем научить бабушку/дедушку логическому программированию, необходимо сначала в принципе объяснить им, что такое программирование, что из себя представляют языки программирования, что такое концепции программирования. Без всяких замедлений, давайте же окунемся в этот поистине увлекательный мир!

## 2. Что такое программирование?

Итак, программирование – это, простым языком, обычное создание программ для компьютера. Надо поделиться с родственниками той мыслью, что весь наш нынешний мир целиком и полностью состоит из этих самых программ, приборов, приспособлений. Более того, ваша бабушка вместе с вашим дедушкой, как и все мы, наверняка каждый день неоднократно контактируют с этими самыми программами – чего только стоит мобильный телефон, в основе которого лежит программное обеспечение, написанное программистами. 

Отлично! Думаю, что небольшая, но очень важная основа для понимания темы в голове наших героев уже заложена. А что же такое языки программирования? Какие они бывают? В чем их разница, в чем сходство? Если вы услышали подобные вопросы от своих родственников, то, уверяю вас, они мыслят в правильном направлении!

## 3. Поговорим о языках

На данные вопросы я бы ответил так: языки программирования – это некие специальные инструменты, посредством которых люди и реализуют свои мысли в разного рода программах. Собственно, именно это и объединяет все языки. Языков программирования поистине куча: С, C++, Python, C#, Java… Я уверен, каждый слышал эти названия. В чем их разница? А разница в том, что каждый из них служит для какой-то своей конкретной цели! 

Язык программирования С, например, называется низкоуровневым. Низкоуровневый язык программирования – это такой язык, где пользователь может напрямую взаимодействовать с “железом” (грубо говоря, с составляющими своего компьютера), работать вручную с  памятью вашего гаджета. Этот язык незаменим для создания компьютерных игр, в разработке программного обеспечения для. Не будь этого языка, ваша бабушка с дедушкой вряд ли бы познали мастерство работы с компьютером, ведь именно язык С считается основой всего, что связано с электронными приборами. 

Следом за ним идет язык программирования С++, созданный Бьёрном Страуструпом в 1950 году. Отличается он от языка С тем, что является более усовершенствованным – а именно, в нем добавили возможность писать код, используя основы объектно-ориентированного-программирования, о котором мы поговорим отдельно.

Популярный в последнее язык Python же используется в анализе данных. В силу своей уже упомянутой низкоуровневости С-языки очень сложны в синтаксисе (синтаксис – это такое понятие, которое характеризует “сложность” прочтения кода). Именно поэтому Python незаменим в тех случаях, когда требуется быстро и незатруднительно реализовать всякую рутинную работу. И так далее…

## 4. Основные концепции и парадигмы программирования

На самом деле, о языках программирования можно говорить очень долго. Я думаю, что описанной выше информации вполне достаточно для того, чтобы ваша бабушка с дедушкой на хорошем уровне поняли то, о чем вы им говорите. На данном этапе мы уже знакомы с тем, что такое программирование, и с чем его едят. Пора перейти к, на мой взгляд, более сложным вещам: к видам и парадигмам программирования.

Пришло время немножечко углубиться в тему программирования и рассмотреть очень важные концепции. На мой взгляд, в мире IT можно выделить сразу несколько важных парадигм программирования:
1) Объектно-ориентированное программирование
2) Функциональное программирование
3) Процедурное программирование
4) Логическое программирование

Давайте рассмотрим каждое из них. Начнем с, пожалуй, самой популярной на данный момент парадигмы. С парадигмы, на которой держится всё современное программирование. Естественно, речь идет об объектно-ориентированном программировании. Зачем вообще нужно ООП? В чем превосходство данной концепции над остальными, почему она настолько популярна?

Что ж, ответ довольно прост: ООП позволяет людям последовательно вызывать команды, которые, в свою очередь, будут изменять данные, с которыми работает ваша программа. Если же подобный ответ не будет понятен вашим бабушке и дедушке, то я бы рекомендовал ответить так: ООП позволяет обобщать огромные, длинные и повторяющиеся участки кода в один блок, а это, в свою очередь, значительно повышает читаемость и понимание написанного на языке программирования кода. В каждом языке программирования ООП реализовано немного по-разному, в связи с чем где-то будет его освоить легче, а где-то сложнее. 


Теперь поговорим о функциональном программировании: оно, стоит отдать должное, стоит на втором месте по популярности после ООП.
Суть его примерно в следующем: подразумевается, что программа создается как некий инструмент, который решает определенную задачу, в конце выдавая нужный пользователю результат. Главное отличие функционального программирования от ООП – малая потребность в использовании данных. В первом случае данные играют явно второстепенную роль, в то время как во втором случае на данных основа вся концепция. В этом, однако, есть свои плюсы: мы можем запросто избежать побочных эффектов при выполнении некоторых функций, а, следовательно, нам будет сложнее повредить данные. 

Что же касается процедурного программирования, то это такой подход, при котором процедурами называют команды, которые применяются в определенном порядке и последовательно вносят изменения в состояние памяти. Только после применения абсолютно всех команд программа выдает результат. В подобном подходе также есть свои плюсы: намного проще писать и поддерживать код “стройным”, нежели в ООП. Однако тут же стоит выделить существенный минус – очень тяжело создавать большие и серьезные проекты, опираясь лишь на одну данную концепцию. 

## 5. Переходим к логическому программированию

И вот мы, наконец, добрались до основной темы нашего эссе. Давайте уделим некоторое время рассмотрению концепции логического программирования. 

Знаете, я тут подумал и понял, что у меня есть повод обрадовать бабушку с дедушкой. Немного поразмыслив, я осознал, что логическое программирование для них будет самым легким концептом для осознания, ведь отчасти это то, что они, будучи еще совсем молодыми, проходили в школах и вузах, особенно, если учились на каком-либо техническом направлении. Судите сами: в основе логического программирования полностью лежит математический аппарат, элементы математической логики, а если быть точнее, то некоторые подразделы дискретной математики. Ведь согласитесь, даже если человек не изучал ничего подобного в школе, ему не сложно будет понять, почему при условном запросе “10 > 0 ?” программа выдаст true (истину), а при запросе “-5 > 0?” программа выдаст false (ложь).

Следует сказать вашим родным, что логическое программирование, по сути, имеет в своей основе абстрактную модель и основано на наборе неких фактов, в связи с чем сильно отклоняется от пути развития привычных нам императивных языков программирования. Из фактов строятся предикаты – специальные вспомогательные средства для решения задачи. При помощи этих самых предикатов конструируются новые факты, созданные на основе старых. А при помощи новых фактов конструируются и выходные данные – то, что мы получаем от программы после окончания ее работы. Иными словами, если обобщить, то результат программы, написанной на логическом языке, напрямую зависит от набора фактов и утверждений. 

## 6. История возникновения логического программирования

По разным данным, парадигма логического программирования возникла напрямую из функционального – математики и лингвисты нуждались в надежном и несложном инструменте для решения разного рода задач символьной обработки. Самым первым языком программирования являлся Planner. В нем была заложена отнюдь нетривиальная возможность автоматического вывода полученного результата из данных и неких заданных правил, по которым должен был осуществляться перебор вариантов. Именно с появлением на свет языка Planer мы на самом деле можем говорить о таком важном понятии, как backtracking. 

Думаю, ваша бабушка и дедушка порядком удивятся, услышав данное слово, но, думаю, стоит их успокоить и сказать, что бэктрекинг – это попросту полный перебор вариантов решений какой-либо задачки. Естественно, это не полное определение данного понятия, ведь по-честному стоило бы упомянуть о некоторых нюансах бэктрекинга, однако мне кажется, что данного нестрогого определения будет вполне себе достаточно.

## 7. Подробнее о Prolog

Так вот, именно данная возможность возврата назад к дереву решений была отличительной возможностью языка Planer, после которого, в далеком 1972 году,  появился гвоздь нашей программы – язык программирования Prolog, который был своеобразным упрощением Planer. Стоит, кстати говоря, отметить, что несмотря на довольно раннее появление на свет, Prolog намного младше некоторых привычных нам императивных языков программирования. Он младше, например, того же самого С++, которого изобрели только в далеком 1950 году.

Давайте продолжим рассматривать концепцию логического программирования на примере языка Prolog. С чего же нам следует сейчас начать? Давайте немножечко поговорим о самом языке. Для чего он нужен, почему он столь популярен среди логических языков?
Что ж, думаю, ответ довольно прост: Prolog является самым многофункциональным языком среди всех остальных, так как он предназначен для очень многих целей. Например, таких как: реализация систем искусственного интеллекта, разработка систем помощи по принятию решений, разработка плана действий роботов, а также разработка систем обработки естественных языков. 

Стоит отметить, что в языке, в основном, выделяют 2 понятия: предикаты и объекты.  Предикаты выражают некоторые условия, на которые мы должны будем опираться в нашей программе. Например: ```70_years_old(Granny).``` – предикат, который говорит, что бабушке 70 лет. Как мы поняли, что именно бабушке? В скобочках указан аргумент предиката, и на месте единственного аргумента стоит “Granny”, то есть бабушка. Аналогично ```70_years_old(Grandfather).```

Объекты – это, по сути, то, с чем Prolog в принципе имеет дело помимо предикатов – объектами являются, в основном, термы и переменные. Так как первое слово, вероятно, бабушке с дедушкой будет слишком тяжело осознать, лучше ограничиться одними переменными. Переменные – это некие условные единицы кода, выражающие неизвестный, скорее всего, искомый объект, обозначаются всегда с большой буквы. Сама же программа на языке Prolog, простым языком говоря, - это некий набор правил. Фактически, пролог-программа похожа на одно большое условие, которое выполняется, подусловия удовлетворяют каким-то нашим конкретным требованиям.

Прежде чем перейти к подробному примеру, мы должны рассмотреть еще несколько очень важных понятий языка Prolog. Например, понятие “рекурсия”. Если объяснить очень коротко, то рекурсия – это некая процедура, которая вызывает себя до тех пор, пока не будет выполнено некое условие (в обычном понимании – возврат к началу), которое остановит рекурсию. Почему же это понятие является важным для осознания концепции логического программирования на языке Prolog? На самом деле, рекурсия – это основополагающее понятие не только в Prolog, но и во всем программировании в целом. Я ввел понятие “рекурсия” для подробного объяснения первого из двух, на мой взгляд, самых важных моделей языка Prolog – списков. Что же такое список? Давайте, для начала, скажем бабушке с дедушкой, что список – это обычная очередь в каком-либо супермаркете. То есть, для фиксированной длины очереди мы должны обратиться к первому человеку, а если очередь произвольной длины, то мы должны идти по головам от человека к человеку. В прологе список обозначается вот так: [Head|Tail]. Что же это значит? Это значит, что список в нашем языке инициализируется при помощи двух условных переменных – Head (голова) и Tail (хвост), где голова – это наш самый первый элемент списка, а Tail – это список из всех остальных элементов исходного списка, не считая нашей головы. 

При чем тут рекурсия? Да при том, что мы можем обходить этот список рекурсивно. То есть, допустим, список ```[1,2,3,4,5]``` мы можем обойти следующим образом: 
```prolog
1) [1|[2,3,4,5]]. Head – 1, Tail – [2,3,4,5].
2) [2|[3,4,5,]]. Head – 2, Tail – [3,4,5].
3) [3|[4,5]]. Head – 3, Tail – [4,5].
4) [4|5]. Head – 4, Tail – 5.
```

То есть с каждым следующим вызовом программы мы сможем перемещаться по списку подобным образом вперед. Опять же, очень похоже на проход по очереди из людей в том же супермаркете. Для начала мы зафиксируем какого-то конкретного человека, и после этого остальные люди в очереди для нас будут так называемым “хвостом”.

Отлично! Я думаю, несмотря на то, что материал довольно сложный, что-то в головах бабушки с дедушкой точно осталось! Теперь давайте перейдем к финальному, очень важному понятию языка Prolog – дерево решений. Дерево решений – это просто множество из всевозможных путей, по которым можно прийти так, чтобы путь являлся нужным нам решением. Это сравнимо со следующей ситуацией: предположим, что бабушке надо дойти до какого-то дома и она сейчас стоит перед светофором в ожидании зеленого сигнала, чтобы пройти дальше. При этом перед ней виднеются 3 разных пути, ведущих к разным домам. При этом готовый путь к дому является решением. Точка, в которой на данном этапе стоит бабушка, является главным узлом нашего дерева решений. Далее, по мере выбора какого-то конкретного начального пути, она, видоизменяя свой маршрут, приходит к какому-то одному дому. Этот результат и является одним из искомых решений.

## 8. Выводы

Что же сказать в конце? Хочется верить, что бабушка с дедушкой оценят мою работу по праву. Вообще, я считаю, что им очень понравится логическое программирование, ведь эта парадигма, на мой взгляд, идеально подходит для нашего случая: программа, написанная на логическом языке, например, на том же самом Prolog, требует только набор фактов и правил. Суть в том, что все основные и весьма непростые понятия наподобие бэктрекинга, дерева решений, списков, уже встроены в сам язык, в связи с чем одно из немногих, о чем нам нужно по-настоящему позаботиться – это внести в наш программный код правильный набор изначальных условий, а далее программа за тебя осуществит необходимый поиск и перебор всевозможных решений. 

Я уверен, что бабушка с дедушкой, изучив на должном уровне логическое программирование, увлекутся и самим программированием в целом! Несмотря на упомянутый во “Введении” факт о том, что немолодому человеку сложнее учиться, я остаюсь при своем старом мнении: всегда всё зависит от желания. Да, возможно, моим близким было бы тяжелее изучить что-то новое, и процесс бы этот занял намного больше времени, чем, например, у моих сверстников, но главное – это всегда результат. Именно поэтому я с превеликим удовольствием буду помогать своим родным и отвечать на каждый их вопрос по освещенной в этом эссе теме, в сердце храня надежду на то, что у них всё получится!



## 9. Список вспомогательных источников

1. Википедия (https://ru.wikipedia.org/)
2. Справочная информация по языку Prolog (http://progopedia.ru/language/prolog/)

